I want to make a ball bounce off of the edges of a screen in pygame this is what I currently have (insert test.py code)

Ai: if x - radius <= 0 or x + radius >= width:
    dx = -dx
    if y - radius <= 0 or y + radius >= width:
    dy = -dy
ME: Is there a way to create a small star effect when the ball hits the furthest point of the corner
AI: Gave this code (import pygame
import sys
import random
import math

# Initialize Pygame
pygame.init()

# Set up the display
width, height = 600, 400
screen = pygame.display.set_mode((width, height))
pygame.display.set_caption("Ball with Corner Stars")

# --- Main Game Loop ---
running = True
x = width // 2
y = height // 2
radius = 50
dx = 2
dy = 2

# Store stars as (x, y, lifetime, size)
stars = []

clock = pygame.time.Clock()

while running:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
            
    # Update position
    x += dx
    y += dy
    
    corner_hit = False

    # Bounce off left and right walls
    if x - radius <= 0 or x + radius >= width:
        dx = -dx
        if y - radius <= 0 or y + radius >= height:
            corner_hit = True

    # Bounce off top and bottom walls
    if y - radius <= 0 or y + radius >= height:
        dy = -dy
        if x - radius <= 0 or x + radius >= width:
            corner_hit = True

    # If corner hit, spawn stars further away
    if corner_hit:
        for _ in range(8):  # number of stars
            angle = random.uniform(0, 2 * math.pi)
            distance = radius + 30  # push stars further out
            sx = x + int(math.cos(angle) * distance)
            sy = y + int(math.sin(angle) * distance)
            stars.append([sx, sy, 30, 6])  # lifetime=30 frames, size=6

    # Update stars (decrease lifetime and shrink)
    for star in stars:
        star[2] -= 1
        star[3] = max(1, star[3] - 0.1)  # shrink size gradually
    stars = [s for s in stars if s[2] > 0]

    # Draw background
    screen.fill((255, 255, 179))

    # Draw ball
    pygame.draw.circle(screen, (0, 0, 255), (x, y), radius)

    # Draw stars (fade color with lifetime)
    for sx, sy, life, size in stars:
        alpha = max(50, life * 8)  # fade out
        color = (255, 255, alpha)  # yellowish-white twinkle
        pygame.draw.circle(screen, color, (sx, sy), int(size))

    # Frame rate
    clock.tick(60)
    pygame.display.flip()

pygame.quit()
sys.exit()
)
ME: CAn we add a twinkle effect to the stars

AI: # Update stars (decrease lifetime and shrink)
    for star in stars:
        star[2] -= 1
        star[3] = max(2, star[3] - 0.2)  # shrink size gradually
    stars = [s for s in stars if s[2] > 0]

    # Draw stars (fade color with lifetime)
    for sx, sy, life, size in stars:
        alpha = max(50, life * 8)  # fade out
        color = (255, 255, alpha)  # yellowish-white twinkle
        draw_star(screen, sx, sy, int(size), color)

ME: Is there a way to add a second ball then add collision to both balls.

AI: import pygame
import sys
import math
import random

# Initialize Pygame
pygame.init()

# Set up the display
width, height = 600, 400
screen = pygame.display.set_mode((width, height))
pygame.display.set_caption("Two Balls with Flying Stars")

clock = pygame.time.Clock()

# --- Ball Class ---
class Ball:
    def __init__(self, x, y, dx, dy, radius, color):
        self.x = x
        self.y = y
        self.dx = dx
        self.dy = dy
        self.radius = radius
        self.color = color

    def move(self):
        self.x += self.dx
        self.y += self.dy

        corner_hit = False

        # Bounce off walls
        if self.x - self.radius <= 0 or self.x + self.radius >= width:
            self.dx = -self.dx
            if self.y - self.radius <= 0 or self.y + self.radius >= height:
                corner_hit = True

        if self.y - self.radius <= 0 or self.y + self.radius >= height:
            self.dy = -self.dy
            if self.x - self.radius <= 0 or self.x + self.radius >= width:
                corner_hit = True

        return corner_hit

    def draw(self, surface):
        pygame.draw.circle(surface, self.color, (int(self.x), int(self.y)), self.radius)

# --- Star Drawing ---
def draw_star(surface, x, y, size, color):
    """Draw a ✦ sparkle"""
    pygame.draw.line(surface, color, (x - size, y), (x + size, y), 2)
    pygame.draw.line(surface, color, (x, y - size), (x, y + size), 2)
    pygame.draw.line(surface, color, (x - size, y - size), (x + size, y + size), 2)
    pygame.draw.line(surface, color, (x - size, y + size), (x + size, y - size), 2)

# --- Create Balls ---
ball1 = Ball(150, 200, 3, 2, 40, (0, 0, 255))   # blue
ball2 = Ball(450, 200, -2, -3, 40, (255, 0, 0)) # red

# Store stars as (x, y, dx, dy, lifetime, size)
stars = []

def spawn_stars(cx, cy, count=10, distance=0, speed=3, size=8, lifetime=30):
    """Spawn stars with outward velocity"""
    for _ in range(count):
        angle = random.uniform(0, 2 * math.pi)
        sx = cx + math.cos(angle) * distance
        sy = cy + math.sin(angle) * distance
        dx = math.cos(angle) * random.uniform(1, speed)
        dy = math.sin(angle) * random.uniform(1, speed)
        stars.append([sx, sy, dx, dy, lifetime, size])

running = True
while running:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False

    # Move balls and check for corner hits
    if ball1.move():
        spawn_stars(ball1.x, ball1.y, count=8, distance=ball1.radius+10, speed=4)

    if ball2.move():
        spawn_stars(ball2.x, ball2.y, count=8, distance=ball2.radius+10, speed=4)

    # --- Ball Collision Detection ---
    dx = ball1.x - ball2.x
    dy = ball1.y - ball2.y
    distance = math.hypot(dx, dy)

    if distance <= ball1.radius + ball2.radius:
        # Swap velocities (simple elastic collision)
        ball1.dx, ball2.dx = ball2.dx, ball1.dx
        ball1.dy, ball2.dy = ball2.dy, ball1.dy

        # Push apart slightly
        overlap = (ball1.radius + ball2.radius) - distance
        angle = math.atan2(dy, dx)
        ball1.x += math.cos(angle) * (overlap / 2)
        ball1.y += math.sin(angle) * (overlap / 2)
        ball2.x -= math.cos(angle) * (overlap / 2)
        ball2.y -= math.sin(angle) * (overlap / 2)

        # Spawn impact stars at collision point
        cx = (ball1.x + ball2.x) / 2
        cy = (ball1.y + ball2.y) / 2
        spawn_stars(cx, cy, count=15, distance=0, speed=5, size=10, lifetime=25)

    # --- Update Stars ---
    for star in stars:
        star[0] += star[2]  # move x
        star[1] += star[3]  # move y
        star[4] -= 1        # decrease lifetime
        star[5] = max(2, star[5] - 0.15)  # shrink
    stars = [s for s in stars if s[4] > 0]

    # --- Draw Everything ---
    screen.fill((255, 255, 179))
    ball1.draw(screen)
    ball2.draw(screen)

    for sx, sy, _, _, life, size in stars:
        alpha = max(50, life * 8)
        color = (255, 255, alpha)
        draw_star(screen, int(sx), int(sy), int(size), color)

    pygame.display.flip()
    clock.tick(60)

pygame.quit()
sys.exit()



ME: Finally lets add 2 more balls for a total of four balls

AI: import pygame
import sys
import math
import random

# Initialize Pygame
pygame.init()

# Set up the display
width, height = 600, 400
screen = pygame.display.set_mode((width, height))
pygame.display.set_caption("Four Balls with Flying Stars")

clock = pygame.time.Clock()

# --- Ball Class ---
class Ball:
    def __init__(self, x, y, dx, dy, radius, color):
        self.x = x
        self.y = y
        self.dx = dx
        self.dy = dy
        self.radius = radius
        self.color = color

    def move(self):
        self.x += self.dx
        self.y += self.dy

        corner_hit = False

        # Bounce off walls
        if self.x - self.radius <= 0 or self.x + self.radius >= width:
            self.dx = -self.dx
            if self.y - self.radius <= 0 or self.y + self.radius >= height:
                corner_hit = True

        if self.y - self.radius <= 0 or self.y + self.radius >= height:
            self.dy = -self.dy
            if self.x - self.radius <= 0 or self.x + self.radius >= width:
                corner_hit = True

        return corner_hit

    def draw(self, surface):
        pygame.draw.circle(surface, self.color, (int(self.x), int(self.y)), self.radius)

# --- Star Drawing ---
def draw_star(surface, x, y, size, color):
    """Draw a ✦ sparkle"""
    pygame.draw.line(surface, color, (x - size, y), (x + size, y), 2)
    pygame.draw.line(surface, color, (x, y - size), (x, y + size), 2)
    pygame.draw.line(surface, color, (x - size, y - size), (x + size, y + size), 2)
    pygame.draw.line(surface, color, (x - size, y + size), (x + size, y - size), 2)

# --- Star Spawning ---
# Store stars as (x, y, dx, dy, lifetime, size)
stars = []

def spawn_stars(cx, cy, count=10, distance=0, speed=3, size=8, lifetime=30):
    """Spawn stars with outward velocity"""
    for _ in range(count):
        angle = random.uniform(0, 2 * math.pi)
        sx = cx + math.cos(angle) * distance
        sy = cy + math.sin(angle) * distance
        dx = math.cos(angle) * random.uniform(1, speed)
        dy = math.sin(angle) * random.uniform(1, speed)
        stars.append([sx, sy, dx, dy, lifetime, size])

# --- Create Four Balls ---
balls = [
    Ball(150, 200, 3, 2, 40, (0, 0, 255)),    # blue
    Ball(450, 200, -2, -3, 40, (255, 0, 0)),  # red
    Ball(300, 100, 2, 3, 30, (0, 200, 0)),    # green
    Ball(300, 300, -3, 2, 35, (200, 0, 200))  # purple
]

running = True
while running:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False

    # Move balls and check for corner hits
    for ball in balls:
        if ball.move():
            spawn_stars(ball.x, ball.y, count=8, distance=ball.radius+10, speed=4)

    # --- Ball Collision Detection (check every pair) ---
    for i in range(len(balls)):
        for j in range(i+1, len(balls)):
            b1, b2 = balls[i], balls[j]
            dx = b1.x - b2.x
            dy = b1.y - b2.y
            distance = math.hypot(dx, dy)

            if distance <= b1.radius + b2.radius:
                # Swap velocities (simple elastic collision)
                b1.dx, b2.dx = b2.dx, b1.dx
                b1.dy, b2.dy = b2.dy, b1.dy

                # Push apart slightly
                overlap = (b1.radius + b2.radius) - distance
                angle = math.atan2(dy, dx)
                b1.x += math.cos(angle) * (overlap / 2)
                b1.y += math.sin(angle) * (overlap / 2)
                b2.x -= math.cos(angle) * (overlap / 2)
                b2.y -= math.sin(angle) * (overlap / 2)

                # Spawn impact stars at collision point
                cx = (b1.x + b2.x) / 2
                cy = (b1.y + b2.y) / 2
                spawn_stars(cx, cy, count=15, distance=0, speed=5, size=10, lifetime=25)

    # --- Update Stars ---
    for star in stars:
        star[0] += star[2]  # move x
        star[1] += star[3]  # move y
        star[4] -= 1        # decrease lifetime
        star[5] = max(2, star[5] - 0.15)  # shrink
    stars = [s for s in stars if s[4] > 0]

    # --- Draw Everything ---
    screen.fill((255, 255, 179))
    for ball in balls:
        ball.draw(screen)

    for sx, sy, _, _, life, size in stars:
        alpha = max(50, life * 8)
        color = (255, 255, alpha)
        draw_star(screen, int(sx), int(sy), int(size), color)

    pygame.display.flip()
    clock.tick(60)

pygame.quit()
sys.exit()
